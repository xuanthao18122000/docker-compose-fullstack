{"version":3,"sources":["../src/internals/assert-schema-keys.ts","../src/internals/omit-prototype.ts","../src/create-query-keys.ts","../src/create-query-key-store.ts","../src/create-mutation-keys.ts","../src/merge-query-keys.ts"],"sourcesContent":["/**\n * @internal ensures no keys provided by the user starts with an _underscore `_`_\n */\nexport const assertSchemaKeys = (schema: Record<string, unknown>): string[] => {\n  const keys = Object.keys(schema).sort((a, b) => a.localeCompare(b));\n\n  const hasKeyInShapeOfInternalKey = keys.some((key) => key.startsWith('_'));\n\n  if (hasKeyInShapeOfInternalKey) {\n    throw new Error('Keys that start with \"_\" are reserved for Query Key Factory');\n  }\n\n  return keys;\n};\n","/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n *\n * @see {@link https://github.com/trpc/trpc/blob/next/packages/server/src/core/internals/omitPrototype.ts tRPC repo for original code }\n */\nexport function omitPrototype<T extends Record<string, unknown>>(obj: T): T {\n  return Object.assign(Object.create(null), obj);\n}\n","import { assertSchemaKeys, omitPrototype } from './internals';\nimport type {\n  QueryFactorySchema,\n  QueryKeyFactoryResult,\n  ValidateFactory,\n  AnyQueryFactoryOutputCallback,\n  AnyQueryKey,\n} from './create-query-keys.types';\nimport { DefinitionKey } from './types';\n\nexport function createQueryKeys<Key extends string>(queryDef: Key): DefinitionKey<[Key]>;\nexport function createQueryKeys<Key extends string, Schema extends QueryFactorySchema>(\n  queryDef: Key,\n  schema: ValidateFactory<Schema>,\n): QueryKeyFactoryResult<Key, ValidateFactory<Schema>>;\nexport function createQueryKeys<Key extends string, Schema extends QueryFactorySchema>(\n  queryDef: Key,\n  schema?: ValidateFactory<Schema>,\n): DefinitionKey<[Key]> | QueryKeyFactoryResult<Key, ValidateFactory<Schema>> {\n  const defKey: DefinitionKey<[Key]> = {\n    _def: [queryDef] as const,\n  };\n\n  if (schema == null) {\n    return omitPrototype(defKey);\n  }\n\n  const transformSchema = <$Factory extends QueryFactorySchema>(factory: $Factory, mainKey: AnyQueryKey) => {\n    type $FactoryProperty = keyof $Factory;\n\n    const keys = assertSchemaKeys(factory);\n    return keys.reduce((factoryMap, factoryKey) => {\n      const value = factory[factoryKey];\n      const key = [...mainKey, factoryKey] as const;\n\n      const isReadonlyArray = (arg: unknown): arg is readonly any[] => Array.isArray(arg);\n\n      let yieldValue: any;\n\n      if (typeof value === 'function') {\n        const resultCallback: AnyQueryFactoryOutputCallback = (...args) => {\n          const result = value(...args);\n\n          if (isReadonlyArray(result)) {\n            return omitPrototype({\n              queryKey: [...key, ...result] as const,\n            });\n          }\n\n          const innerKey = [...key, ...result.queryKey] as const;\n\n          if ('queryFn' in result) {\n            // type $QueryFnContext = Omit<QueryFunctionContext<typeof innerKey, any>, 'queryKey'>;\n\n            const queryOptions = {\n              queryKey: innerKey,\n              queryFn: result.queryFn,\n            };\n\n            if ('contextQueries' in result) {\n              const transformedSchema = transformSchema(result.contextQueries, innerKey);\n\n              return omitPrototype({\n                _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n                ...queryOptions,\n              });\n            }\n\n            return omitPrototype({\n              ...queryOptions,\n            });\n          }\n\n          if ('contextQueries' in result) {\n            const transformedSchema = transformSchema(result.contextQueries, innerKey);\n\n            return omitPrototype({\n              _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n              queryKey: innerKey,\n            });\n          }\n\n          return omitPrototype({\n            queryKey: innerKey,\n          });\n        };\n\n        resultCallback._def = key;\n\n        yieldValue = resultCallback;\n      } else if (value == null) {\n        yieldValue = omitPrototype({\n          queryKey: key,\n        });\n      } else if (isReadonlyArray(value)) {\n        yieldValue = omitPrototype({\n          _def: key,\n          queryKey: [...key, ...value] as const,\n        });\n      } else if ('queryFn' in value) {\n        // type $QueryFnContext = Omit<QueryFunctionContext<typeof innerKey, any>, 'queryKey'>;\n\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        const queryOptions = {\n          queryKey: innerKey,\n          queryFn: value.queryFn,\n        };\n\n        if ('contextQueries' in value) {\n          const transformedSchema = transformSchema(value.contextQueries, innerKey);\n\n          yieldValue = omitPrototype({\n            _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n            ...innerDefKey,\n            ...queryOptions,\n          });\n        } else {\n          yieldValue = omitPrototype({ ...innerDefKey, ...queryOptions });\n        }\n      } else if ('contextQueries' in value) {\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        const transformedSchema = transformSchema(value.contextQueries, innerKey);\n\n        yieldValue = omitPrototype({\n          _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n          queryKey: innerKey,\n          ...innerDefKey,\n        });\n      } else {\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        yieldValue = omitPrototype({\n          queryKey: innerKey,\n          ...innerDefKey,\n        });\n      }\n\n      factoryMap.set(factoryKey, yieldValue);\n      return factoryMap;\n    }, new Map<$FactoryProperty, $Factory[$FactoryProperty]>());\n  };\n\n  const transformedSchema = transformSchema(schema, defKey._def);\n\n  return omitPrototype({\n    ...Object.fromEntries(transformedSchema),\n    ...defKey,\n  });\n}\n","import { createQueryKeys } from './create-query-keys';\nimport type { QueryFactorySchema, QueryKeyFactoryResult } from './create-query-keys.types';\nimport type { DefinitionKey } from './types';\nimport { omitPrototype } from './internals';\n\ntype QueryKeyStoreSchema = Record<string, null | QueryFactorySchema>;\n\nexport type QueryKeyStore<StoreSchema extends QueryKeyStoreSchema> = {\n  [P in keyof StoreSchema & string]: StoreSchema[P] extends QueryFactorySchema\n    ? QueryKeyFactoryResult<P, StoreSchema[P]>\n    : DefinitionKey<[P]>;\n};\n\nexport function createQueryKeyStore<StoreSchema extends QueryKeyStoreSchema>(\n  schema: StoreSchema,\n): QueryKeyStore<StoreSchema> {\n  const keys = Object.keys(schema);\n\n  const store = keys.reduce((storeMap, key) => {\n    const factory = schema[key];\n\n    const result = factory ? createQueryKeys(key, factory) : createQueryKeys(key);\n\n    storeMap.set(key, result);\n    return storeMap;\n  }, new Map());\n\n  return omitPrototype(Object.fromEntries(store));\n}\n","import type {\n  MutationFactorySchema,\n  MutationKeyFactoryResult,\n  AnyMutationFactoryOutputCallback,\n  ValidateFactory,\n  AnyMutationKey,\n} from './create-mutation-keys.types';\nimport { assertSchemaKeys, omitPrototype } from './internals';\nimport type { DefinitionKey } from './types';\n\n/**\n * @deprecated the type inference for this function is broken and will be fixed in the next patch version\n * or possibly removed and implemented differently in a major version\n */\nexport function createMutationKeys<Key extends string>(mutationDef: Key): DefinitionKey<[Key]>;\n/**\n * @deprecated the type inference for this function is broken and will be fixed in the next patch version\n * or possibly removed and implemented differently in a major version\n */\nexport function createMutationKeys<Key extends string, Schema extends MutationFactorySchema>(\n  mutationDef: Key,\n  schema: ValidateFactory<Schema>,\n): MutationKeyFactoryResult<Key, Schema>;\n/**\n * @deprecated the type inference for this function is broken and will be fixed in the next patch version\n * or possibly removed and implemented differently in a major version\n */\nexport function createMutationKeys<Key extends string, Schema extends MutationFactorySchema>(\n  mutationDef: Key,\n  schema?: ValidateFactory<Schema>,\n): DefinitionKey<[Key]> | MutationKeyFactoryResult<Key, Schema> {\n  const defKey: DefinitionKey<[Key]> = {\n    _def: [mutationDef] as const,\n  };\n\n  if (schema == null) {\n    return omitPrototype(defKey);\n  }\n\n  const transformSchema = <$Factory extends MutationFactorySchema>(factory: $Factory, mainKey: AnyMutationKey) => {\n    type $FactoryProperty = keyof $Factory;\n\n    const keys = assertSchemaKeys(factory);\n    return keys.reduce((factoryMap, factoryKey) => {\n      const value = factory[factoryKey];\n      const key = [...mainKey, factoryKey] as const;\n\n      const isReadonlyArray = (arg: unknown): arg is readonly any[] => Array.isArray(arg);\n\n      let yieldValue: any;\n\n      if (typeof value === 'function') {\n        const resultCallback: AnyMutationFactoryOutputCallback = (...args) => {\n          const result = value(...args);\n\n          if (isReadonlyArray(result)) {\n            return omitPrototype({\n              mutationKey: [...key, ...result] as const,\n            });\n          }\n\n          const innerKey = [...key, ...result.mutationKey] as const;\n\n          if ('mutationFn' in result) {\n            const queryOptions = {\n              mutationKey: innerKey,\n              mutationFn: result.mutationFn,\n            };\n\n            if ('contextMutations' in result) {\n              const transformedSchema = transformSchema(result.contextMutations, innerKey);\n\n              return omitPrototype({\n                _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n                ...queryOptions,\n              });\n            }\n\n            return omitPrototype({\n              ...queryOptions,\n            });\n          }\n\n          if ('contextMutations' in result) {\n            const transformedSchema = transformSchema(result.contextMutations, innerKey);\n\n            return omitPrototype({\n              _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n              mutationKey: innerKey,\n            });\n          }\n\n          return omitPrototype({\n            mutationKey: innerKey,\n          });\n        };\n\n        resultCallback._def = key;\n\n        yieldValue = resultCallback;\n      } else if (value == null) {\n        yieldValue = omitPrototype({\n          mutationKey: key,\n        });\n      } else if (isReadonlyArray(value)) {\n        yieldValue = omitPrototype({\n          _def: key,\n          mutationKey: [...key, ...value] as const,\n        });\n      } else if ('mutationFn' in value) {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        const queryOptions = {\n          mutationKey: innerKey,\n          mutationFn: value.mutationFn,\n        };\n\n        if ('contextMutations' in value) {\n          const transformedSchema = transformSchema(value.contextMutations, innerKey);\n\n          yieldValue = omitPrototype({\n            _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n            ...innerDefKey,\n            ...queryOptions,\n          });\n        } else {\n          yieldValue = omitPrototype({ ...innerDefKey, ...queryOptions });\n        }\n      } else if ('contextMutations' in value) {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        const transformedSchema = transformSchema(value.contextMutations, innerKey);\n\n        yieldValue = omitPrototype({\n          _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n          mutationKey: innerKey,\n          ...innerDefKey,\n        });\n      } else {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        yieldValue = omitPrototype({\n          mutationKey: innerKey,\n          ...innerDefKey,\n        });\n      }\n\n      factoryMap.set(factoryKey, yieldValue);\n      return factoryMap;\n    }, new Map<$FactoryProperty, $Factory[$FactoryProperty]>());\n  };\n\n  const transformedSchema = transformSchema(schema, defKey._def);\n\n  return omitPrototype({\n    ...Object.fromEntries(transformedSchema),\n    ...defKey,\n  });\n}\n","import { AnyMutationKeyFactoryResult } from './create-mutation-keys.types';\nimport type { AnyQueryKeyFactoryResult } from './create-query-keys.types';\nimport { type Add, omitPrototype } from './internals';\n\ntype StoreFromMergedQueryKeys<\n  QueryOrMutationKeyFactoryResults extends Array<AnyQueryKeyFactoryResult | AnyMutationKeyFactoryResult>,\n  CurrentIndex extends number = 0,\n> = QueryOrMutationKeyFactoryResults[CurrentIndex] extends null | undefined\n  ? {}\n  : {\n      [P in QueryOrMutationKeyFactoryResults[CurrentIndex]['_def'][0]]: QueryOrMutationKeyFactoryResults[CurrentIndex];\n    } & StoreFromMergedQueryKeys<QueryOrMutationKeyFactoryResults, Add<CurrentIndex, 1>>;\n\nexport function mergeQueryKeys<\n  QueryKeyFactoryResults extends Array<AnyQueryKeyFactoryResult | AnyMutationKeyFactoryResult>,\n>(...schemas: QueryKeyFactoryResults): StoreFromMergedQueryKeys<QueryKeyFactoryResults> {\n  const store = schemas.reduce((storeMap, current) => {\n    const [storeKey] = current._def;\n\n    storeMap.set(storeKey, { ...storeMap.get(storeKey), ...current });\n    return storeMap;\n  }, new Map());\n\n  return omitPrototype(Object.fromEntries(store));\n}\n"],"mappings":"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","names":["assertSchemaKeys","schema","keys","a","b","key","omitPrototype","obj","createQueryKeys","queryDef","schema","defKey","omitPrototype","transformSchema","factory","mainKey","assertSchemaKeys","factoryMap","factoryKey","value","key","isReadonlyArray","arg","yieldValue","resultCallback","args","result","innerKey","queryOptions","transformedSchema","innerDefKey","createQueryKeyStore","schema","store","storeMap","key","factory","result","createQueryKeys","omitPrototype","createMutationKeys","mutationDef","schema","defKey","omitPrototype","transformSchema","factory","mainKey","assertSchemaKeys","factoryMap","factoryKey","value","key","isReadonlyArray","arg","yieldValue","resultCallback","args","result","innerKey","queryOptions","transformedSchema","innerDefKey","mergeQueryKeys","schemas","store","storeMap","current","storeKey","omitPrototype"]}