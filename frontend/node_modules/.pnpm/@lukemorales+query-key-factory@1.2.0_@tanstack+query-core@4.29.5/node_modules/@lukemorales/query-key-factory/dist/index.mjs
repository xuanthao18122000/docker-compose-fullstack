function e(m){return Object.assign(Object.create(null),m)}var S=m=>{let K=Object.keys(m).sort((y,u)=>y.localeCompare(u));if(K.some(y=>y.startsWith("_")))throw new Error('Keys that start with "_" are reserved for the Query Key Factory');return K};function h(m,K){let i={_def:[m]};if(K==null)return e(i);let y=(d,F)=>S(d).reduce((p,l)=>{let t=d[l],n=[...F,l],x=o=>Array.isArray(o),a;if(typeof t=="function"){let o=(...s)=>{let r=t(...s);if(x(r))return e({queryKey:[...n,...r]});let c=[...n,...r.queryKey];if("queryFn"in r){let f={queryKey:c,queryFn:r.queryFn};if("contextQueries"in r){let Q=y(r.contextQueries,c);return e({_ctx:e(Object.fromEntries(Q)),...f})}return e({...f})}if("contextQueries"in r){let f=y(r.contextQueries,c);return e({_ctx:e(Object.fromEntries(f)),queryKey:c})}return e({queryKey:c})};o._def=n,a=o}else if(t==null)a=e({queryKey:n});else if(x(t))a=e({_def:n,queryKey:[...n,...t]});else if("queryFn"in t){let o={...t.queryKey?{_def:n}:void 0},s=[...n,...t.queryKey??[]],r={queryKey:s,queryFn:t.queryFn};if("contextQueries"in t){let c=y(t.contextQueries,s);a=e({_ctx:e(Object.fromEntries(c)),...o,...r})}else a=e({...o,...r})}else if("contextQueries"in t){let o={...t.queryKey?{_def:n}:void 0},s=[...n,...t.queryKey??[]],r=y(t.contextQueries,s);a=e({_ctx:e(Object.fromEntries(r)),queryKey:s,...o})}else{let o={...t.queryKey?{_def:n}:void 0},s=[...n,...t.queryKey??[]];a=e({queryKey:s,...o})}return p.set(l,a),p},new Map),u=y(K,i._def);return e({...Object.fromEntries(u),...i})}function M(m){let i=Object.keys(m).reduce((y,u)=>{let d=m[u],F=d?h(u,d):h(u);return y.set(u,F),y},new Map);return e(Object.fromEntries(i))}function O(m,K){let i={_def:[m]};if(K==null)return e(i);let y=(d,F)=>S(d).reduce((p,l)=>{let t=d[l],n=[...F,l],x=o=>Array.isArray(o),a;if(typeof t=="function"){let o=(...s)=>{let r=t(...s);if(x(r))return e({mutationKey:[...n,...r]});let c=[...n,...r.mutationKey];if("mutationFn"in r){let f={mutationKey:c,mutationFn:r.mutationFn};if("contextMutations"in r){let Q=y(r.contextMutations,c);return e({_ctx:e(Object.fromEntries(Q)),...f})}return e({...f})}if("contextMutations"in r){let f=y(r.contextMutations,c);return e({_ctx:e(Object.fromEntries(f)),mutationKey:c})}return e({mutationKey:c})};o._def=n,a=o}else if(t==null)a=e({mutationKey:n});else if(x(t))a=e({_def:n,mutationKey:[...n,...t]});else if("mutationFn"in t){let o={...t.mutationKey?{_def:n}:void 0},s=[...n,...t.mutationKey??[]],r={mutationKey:s,mutationFn:t.mutationFn};if("contextMutations"in t){let c=y(t.contextMutations,s);a=e({_ctx:e(Object.fromEntries(c)),...o,...r})}else a=e({...o,...r})}else if("contextMutations"in t){let o={...t.mutationKey?{_def:n}:void 0},s=[...n,...t.mutationKey??[]],r=y(t.contextMutations,s);a=e({_ctx:e(Object.fromEntries(r)),mutationKey:s,...o})}else{let o={...t.mutationKey?{_def:n}:void 0},s=[...n,...t.mutationKey??[]];a=e({mutationKey:s,...o})}return p.set(l,a),p},new Map),u=y(K,i._def);return e({...Object.fromEntries(u),...i})}function _(...m){let K=m.reduce((i,y)=>{let[u]=y._def;return i.set(u,{...i.get(u),...y}),i},new Map);return e(Object.fromEntries(K))}export{O as createMutationKeys,M as createQueryKeyStore,h as createQueryKeys,_ as mergeQueryKeys};
//# sourceMappingURL=index.mjs.map