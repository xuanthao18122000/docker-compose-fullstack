{
  "version": 3,
  "sources": ["../../.pnpm/@lukemorales+query-key-factory@1.2.0_@tanstack+query-core@4.29.5/node_modules/@lukemorales/query-key-factory/src/internals/omit-prototype.ts", "../../.pnpm/@lukemorales+query-key-factory@1.2.0_@tanstack+query-core@4.29.5/node_modules/@lukemorales/query-key-factory/src/internals/assert-schema-keys.ts", "../../.pnpm/@lukemorales+query-key-factory@1.2.0_@tanstack+query-core@4.29.5/node_modules/@lukemorales/query-key-factory/src/create-query-keys.ts", "../../.pnpm/@lukemorales+query-key-factory@1.2.0_@tanstack+query-core@4.29.5/node_modules/@lukemorales/query-key-factory/src/create-query-key-store.ts", "../../.pnpm/@lukemorales+query-key-factory@1.2.0_@tanstack+query-core@4.29.5/node_modules/@lukemorales/query-key-factory/src/create-mutation-keys.ts", "../../.pnpm/@lukemorales+query-key-factory@1.2.0_@tanstack+query-core@4.29.5/node_modules/@lukemorales/query-key-factory/src/merge-query-keys.ts"],
  "sourcesContent": ["/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n *\n * @see {@link https://github.com/trpc/trpc/blob/next/packages/server/src/core/internals/omitPrototype.ts tRPC repo for original code }\n */\nexport function omitPrototype<T extends Record<string, unknown>>(obj: T): T {\n  return Object.assign(Object.create(null), obj);\n}\n", "/**\n * @internal\n */\nexport const assertSchemaKeys = (schema: Record<string, unknown>): string[] => {\n  const keys = Object.keys(schema).sort((a, b) => a.localeCompare(b));\n\n  const hasKeyInShapeOfInternalKey = keys.some((key) => key.startsWith('_'));\n\n  if (hasKeyInShapeOfInternalKey) {\n    throw new Error('Keys that start with \"_\" are reserved for the Query Key Factory');\n  }\n\n  return keys;\n};\n", "import { omitPrototype } from './internals';\nimport { assertSchemaKeys } from './internals/assert-schema-keys';\nimport type {\n  DefinitionKey,\n  QueryFactorySchema,\n  QueryKeyFactoryResult,\n  ValidateFactory,\n  AnyQueryFactoryOutputCallback,\n  AnyQueryKey,\n} from './types';\n\nexport function createQueryKeys<Key extends string>(queryDef: Key): DefinitionKey<[Key]>;\nexport function createQueryKeys<Key extends string, Schema extends QueryFactorySchema>(\n  queryDef: Key,\n  schema: ValidateFactory<Schema>,\n): QueryKeyFactoryResult<Key, Schema>;\nexport function createQueryKeys<Key extends string, Schema extends QueryFactorySchema>(\n  queryDef: Key,\n  schema?: ValidateFactory<Schema>,\n): DefinitionKey<[Key]> | QueryKeyFactoryResult<Key, Schema> {\n  const defKey: DefinitionKey<[Key]> = {\n    _def: [queryDef] as const,\n  };\n\n  if (schema == null) {\n    return omitPrototype(defKey);\n  }\n\n  const transformSchema = <$Factory extends QueryFactorySchema>(factory: $Factory, mainKey: AnyQueryKey) => {\n    type $FactoryProperty = keyof $Factory;\n\n    const keys = assertSchemaKeys(factory);\n    return keys.reduce((factoryMap, factoryKey) => {\n      const value = factory[factoryKey];\n      const key = [...mainKey, factoryKey] as const;\n\n      const isReadonlyArray = (arg: unknown): arg is readonly any[] => Array.isArray(arg);\n\n      let yieldValue: any;\n\n      if (typeof value === 'function') {\n        const resultCallback: AnyQueryFactoryOutputCallback = (...args) => {\n          const result = value(...args);\n\n          if (isReadonlyArray(result)) {\n            return omitPrototype({\n              queryKey: [...key, ...result] as const,\n            });\n          }\n\n          const innerKey = [...key, ...result.queryKey] as const;\n\n          if ('queryFn' in result) {\n            // type $QueryFnContext = Omit<QueryFunctionContext<typeof innerKey, any>, 'queryKey'>;\n\n            const queryOptions = {\n              queryKey: innerKey,\n              queryFn: result.queryFn,\n            };\n\n            if ('contextQueries' in result) {\n              const transformedSchema = transformSchema(result.contextQueries, innerKey);\n\n              return omitPrototype({\n                _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n                ...queryOptions,\n              });\n            }\n\n            return omitPrototype({\n              ...queryOptions,\n            });\n          }\n\n          if ('contextQueries' in result) {\n            const transformedSchema = transformSchema(result.contextQueries, innerKey);\n\n            return omitPrototype({\n              _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n              queryKey: innerKey,\n            });\n          }\n\n          return omitPrototype({\n            queryKey: innerKey,\n          });\n        };\n\n        resultCallback._def = key;\n\n        yieldValue = resultCallback;\n      } else if (value == null) {\n        yieldValue = omitPrototype({\n          queryKey: key,\n        });\n      } else if (isReadonlyArray(value)) {\n        yieldValue = omitPrototype({\n          _def: key,\n          queryKey: [...key, ...value] as const,\n        });\n      } else if ('queryFn' in value) {\n        // type $QueryFnContext = Omit<QueryFunctionContext<typeof innerKey, any>, 'queryKey'>;\n\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        const queryOptions = {\n          queryKey: innerKey,\n          queryFn: value.queryFn,\n        };\n\n        if ('contextQueries' in value) {\n          const transformedSchema = transformSchema(value.contextQueries, innerKey);\n\n          yieldValue = omitPrototype({\n            _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n            ...innerDefKey,\n            ...queryOptions,\n          });\n        } else {\n          yieldValue = omitPrototype({ ...innerDefKey, ...queryOptions });\n        }\n      } else if ('contextQueries' in value) {\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        const transformedSchema = transformSchema(value.contextQueries, innerKey);\n\n        yieldValue = omitPrototype({\n          _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n          queryKey: innerKey,\n          ...innerDefKey,\n        });\n      } else {\n        const innerDefKey = { ...(value.queryKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.queryKey ?? [])] as const;\n\n        yieldValue = omitPrototype({\n          queryKey: innerKey,\n          ...innerDefKey,\n        });\n      }\n\n      factoryMap.set(factoryKey, yieldValue);\n      return factoryMap;\n    }, new Map<$FactoryProperty, $Factory[$FactoryProperty]>());\n  };\n\n  const transformedSchema = transformSchema(schema, defKey._def);\n\n  return omitPrototype({\n    ...Object.fromEntries(transformedSchema),\n    ...defKey,\n  });\n}\n", "import { createQueryKeys } from './create-query-keys';\nimport { omitPrototype } from './internals';\nimport { QueryKeyStoreSchema, QueryKeyStore } from './types';\n\nexport function createQueryKeyStore<StoreSchema extends QueryKeyStoreSchema>(\n  schema: StoreSchema,\n): QueryKeyStore<StoreSchema> {\n  const keys = Object.keys(schema);\n\n  const store = keys.reduce((storeMap, key) => {\n    const factory = schema[key];\n\n    const result = factory ? createQueryKeys(key, factory) : createQueryKeys(key);\n\n    storeMap.set(key, result);\n    return storeMap;\n  }, new Map());\n\n  return omitPrototype(Object.fromEntries(store));\n}\n", "import { omitPrototype } from './internals';\nimport { assertSchemaKeys } from './internals/assert-schema-keys';\nimport type {\n  DefinitionKey,\n  MutationFactorySchema,\n  MutationKeyFactoryResult,\n  ValidateFactory,\n  AnyMutationFactoryOutputCallback,\n  AnyMutationKey,\n} from './types';\n\nexport function createMutationKeys<Key extends string>(mutationDef: Key): DefinitionKey<[Key]>;\nexport function createMutationKeys<Key extends string, Schema extends MutationFactorySchema>(\n  mutationDef: Key,\n  schema: ValidateFactory<Schema>,\n): MutationKeyFactoryResult<Key, Schema>;\nexport function createMutationKeys<Key extends string, Schema extends MutationFactorySchema>(\n  mutationDef: Key,\n  schema?: ValidateFactory<Schema>,\n): DefinitionKey<[Key]> | MutationKeyFactoryResult<Key, Schema> {\n  const defKey: DefinitionKey<[Key]> = {\n    _def: [mutationDef] as const,\n  };\n\n  if (schema == null) {\n    return omitPrototype(defKey);\n  }\n\n  const transformSchema = <$Factory extends MutationFactorySchema>(factory: $Factory, mainKey: AnyMutationKey) => {\n    type $FactoryProperty = keyof $Factory;\n\n    const keys = assertSchemaKeys(factory);\n    return keys.reduce((factoryMap, factoryKey) => {\n      const value = factory[factoryKey];\n      const key = [...mainKey, factoryKey] as const;\n\n      const isReadonlyArray = (arg: unknown): arg is readonly any[] => Array.isArray(arg);\n\n      let yieldValue: any;\n\n      if (typeof value === 'function') {\n        const resultCallback: AnyMutationFactoryOutputCallback = (...args) => {\n          const result = value(...args);\n\n          if (isReadonlyArray(result)) {\n            return omitPrototype({\n              mutationKey: [...key, ...result] as const,\n            });\n          }\n\n          const innerKey = [...key, ...result.mutationKey] as const;\n\n          if ('mutationFn' in result) {\n            const queryOptions = {\n              mutationKey: innerKey,\n              mutationFn: result.mutationFn,\n            };\n\n            if ('contextMutations' in result) {\n              const transformedSchema = transformSchema(result.contextMutations, innerKey);\n\n              return omitPrototype({\n                _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n                ...queryOptions,\n              });\n            }\n\n            return omitPrototype({\n              ...queryOptions,\n            });\n          }\n\n          if ('contextMutations' in result) {\n            const transformedSchema = transformSchema(result.contextMutations, innerKey);\n\n            return omitPrototype({\n              _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n              mutationKey: innerKey,\n            });\n          }\n\n          return omitPrototype({\n            mutationKey: innerKey,\n          });\n        };\n\n        resultCallback._def = key;\n\n        yieldValue = resultCallback;\n      } else if (value == null) {\n        yieldValue = omitPrototype({\n          mutationKey: key,\n        });\n      } else if (isReadonlyArray(value)) {\n        yieldValue = omitPrototype({\n          _def: key,\n          mutationKey: [...key, ...value] as const,\n        });\n      } else if ('mutationFn' in value) {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        const queryOptions = {\n          mutationKey: innerKey,\n          mutationFn: value.mutationFn,\n        };\n\n        if ('contextMutations' in value) {\n          const transformedSchema = transformSchema(value.contextMutations, innerKey);\n\n          yieldValue = omitPrototype({\n            _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n            ...innerDefKey,\n            ...queryOptions,\n          });\n        } else {\n          yieldValue = omitPrototype({ ...innerDefKey, ...queryOptions });\n        }\n      } else if ('contextMutations' in value) {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        const transformedSchema = transformSchema(value.contextMutations, innerKey);\n\n        yieldValue = omitPrototype({\n          _ctx: omitPrototype(Object.fromEntries(transformedSchema)),\n          mutationKey: innerKey,\n          ...innerDefKey,\n        });\n      } else {\n        const innerDefKey = { ...(value.mutationKey ? { _def: key } : undefined) };\n        const innerKey = [...key, ...(value.mutationKey ?? [])] as const;\n\n        yieldValue = omitPrototype({\n          mutationKey: innerKey,\n          ...innerDefKey,\n        });\n      }\n\n      factoryMap.set(factoryKey, yieldValue);\n      return factoryMap;\n    }, new Map<$FactoryProperty, $Factory[$FactoryProperty]>());\n  };\n\n  const transformedSchema = transformSchema(schema, defKey._def);\n\n  return omitPrototype({\n    ...Object.fromEntries(transformedSchema),\n    ...defKey,\n  });\n}\n", "import { omitPrototype } from './internals';\nimport { AnyMutationKeyFactoryResult, AnyQueryKeyFactoryResult, StoreFromMergedQueryKeys } from './types';\n\nexport function mergeQueryKeys<\n  QueryKeyFactoryResults extends Array<AnyQueryKeyFactoryResult | AnyMutationKeyFactoryResult>,\n>(...schemas: QueryKeyFactoryResults): StoreFromMergedQueryKeys<QueryKeyFactoryResults> {\n  const store = schemas.reduce((storeMap, current) => {\n    const [storeKey] = current._def;\n\n    storeMap.set(storeKey, { ...storeMap.get(storeKey), ...current });\n    return storeMap;\n  }, new Map());\n\n  return omitPrototype(Object.fromEntries(store));\n}\n"],
  "mappings": "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",
  "names": ["omitPrototype", "obj", "assertSchemaKeys", "schema", "keys", "a", "b", "key", "createQueryKeys", "queryDef", "defKey", "transformSchema", "factory", "mainKey", "factoryMap", "factoryKey", "value", "isReadonlyArray", "arg", "yieldValue", "resultCallback", "args", "result", "innerKey", "queryOptions", "transformedSchema", "innerDefKey", "createQueryKeyStore", "store", "storeMap", "createMutationKeys", "mutationDef", "mergeQueryKeys", "schemas", "current", "storeKey"]
}
